import { CodeGroup } from "@/components/forMdx";

# Creating and updating CoValues in a form

Normally we implement forms using
[just the onSubmit handler](https://react.dev/reference/react-dom/components/form#handle-form-submission-on-the-client),
or by making [a controlled form with useState](https://christinakozanian.medium.com/building-controlled-forms-with-usestate-in-react-f9053ad255a0),
or by using special libraries like [react-hook-form](https://www.react-hook-form.com).


In Jazz, we can do something simpler and more powerful, because CoValues give us reactive,
persisted state which we can use to directly edit live objects, as well as to represent auto-saved drafts.

## Updating a CoValue

You simply assign the new value directly as changes happen. These changes are synced to the server, which means
you don't need to handle form submissions either.

<CodeGroup>
```tsx
<input
  type="text"
  value={order.name}
  onChange={(e) => order.name = e.target.value}
/>
```
</CodeGroup>

This means we can write update forms in fewer lines of code.

## Creating a CoValue

However, when creating a CoValue, the CoValue does not exist yet, so we don't have the advantages previously mentioned.

There's a way around this, and it provides unexpected benefits too.

### Using a Draft CoValue

Let's say we have a CoValue called `BubbleTeaOrder`. We can create a "draft" CoValue,
which is an empty version of a `BubbleTeaOrder`, that we can then modify when we are "creating"
a new CoValue.

A `DraftBubbleTeaOrder` is essentially a copy of `BubbleTeaOrder`, but with all the fields made optional.

<CodeGroup>
```tsx
// schema.ts
export class BubbleTeaOrder extends CoMap {
  name = co.string;
}

export class DraftBubbleTeaOrder extends CoMap {
  name = co.optional.string;
}
```
</CodeGroup>

Then, each Account will have a `DraftBubbleTeaOrder`.

<CodeGroup>
```tsx
// schema.ts
export class AccountRoot extends CoMap {
  draft = co.ref(DraftBubbleTeaOrder);
}

export class JazzAccount extends Account {
  root = co.ref(AccountRoot);

  migrate(this: JazzAccount, creationProps?: { name: string }) {
    super.migrate(creationProps);

    if (!this._refs.root) {
      const ownership = { owner: this };
      const draft = DraftBubbleTeaOrder.create(
        {}, ownership,
      );

      this.root = AccountRoot.create({ draft }, ownership);
    }
  }
}
```
</CodeGroup>

### Form for creating a CoValue

Using the draft, we can treat the create form the same way as the edit form.

Creating an order consists of:
1. Editing the draft order
2. Converting the draft order to a "real" order on submit

Now, let's put all that into practice.

## Defining the schema

Let's start with creating the full schema.

<CodeGroup>
```ts
// schema.ts
export class BubbleTeaOrder extends CoMap {
  name = co.string;
}

export class DraftBubbleTeaOrder extends CoMap {
  name = co.optional.string;
}

export class ListOfBubbleTeaOrders extends CoList.Of(co.ref(BubbleTeaOrder)) {}

export class AccountRoot extends CoMap {
  draft = co.ref(DraftBubbleTeaOrder);
  orders = co.ref(ListOfBubbleTeaOrders);
}

export class JazzAccount extends Account {
  root = co.ref(AccountRoot);

  migrate(this: JazzAccount, creationProps?: { name: string }) {
    super.migrate(creationProps);

    if (!this._refs.root) {
      const ownership = { owner: this };

      const orders = ListOfBubbleTeaOrders.create([], ownership);
      const draft = DraftBubbleTeaOrder.create(
        {}, ownership,
      );

      this.root = AccountRoot.create({ draft, orders }, ownership);
    }
  }
}
```
</CodeGroup>

Learn more about [defining schemas](/docs/schemas/covalues).

## Writing the components in React

Next, let's write the form component that will be used for both create and update.

<CodeGroup>
```tsx
// OrderForm.tsx
export function OrderForm({
  order,
  onSave,
}: {
  order: BubbleTeaOrder | DraftBubbleTeaOrder;
  onSave?: (e: React.FormEvent<HTMLFormElement>) => void;
}) {
  return (
    <form onSubmit={onSave}>
      <label>
        Name
        <input
          type="text"
          value={order.name}
          onChange={(e) => (order.name = e.target.value)}
          required
        />
      </label>

      {onSave && <button type="submit">Submit</button>}
    </form>
  );
}
```
</CodeGroup>

To make the edit form, simply pass the `BubbleTeaOrder`.

<CodeGroup>
```tsx
// EditOrder.tsx
export function EditOrder(props: { id: ID<BubbleTeaOrder> }) {
  const order = useCoState(BubbleTeaOrder, props.id, []);

  if (!order) return;

  return <OrderForm order={order} />;
}
```
</CodeGroup>

For the create form, we need to:
1. Pass the draft to `<OrderForm/>`.
2. When the form is submitted, turn the draft into a real order.
3. Create a new empty draft to reset the form.
4. Subscribe to the new draft.

Here's how that looks like:

<CodeGroup>
```tsx
// CreateOrder.tsx
export function CreateOrder() {
  const { me } = useAccount({ root: { draft: {}, orders: [] } });

  if (!me?.root) return;

  const onSave = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    // turn the draft into a real order
    me.root.orders.push(me.root.draft as BubbleTeaOrder);

    // create a new empty draft
    me.root.draft = DraftBubbleTeaOrder.create(
      {}, { owner: me },
    );
  };

  return <CreateOrderForm id={me?.root?.draft.id} onSave={onSave} />
}

function CreateOrderForm({
  id,
  onSave,
}: {
  id: ID<DraftBubbleTeaOrder>;
  onSave: (e: React.FormEvent<HTMLFormElement>) => void;
}) {
  const draft = useCoState(DraftBubbleTeaOrder, id);

  if (!draft) return;

  return <OrderForm order={draft} onSave={onSave} />;
}
```
</CodeGroup>

When the new draft is created, we need to call `useCoState` again, so that we are passing the new draft to `<OrderForm/>`.

There you have it!

## Validation

In a `BubbleTeaOrder`, the `name` field is required, so it would be a good idea to validate this before turning the draft into a real order.

Update the schema to include a `validate` method.

<CodeGroup>
```ts
// schema.ts
export class DraftBubbleTeaOrder extends CoMap { // old
  name = co.optional.string; // old

  validate() {
    const errors: string[] = [];

    if (!this.name) {
      errors.push("Plese enter a name.");
    }

    return { errors };
  }
} // old
```
</CodeGroup>

Then perform the validation on submit.

<CodeGroup>
```tsx
// CreateOrder.tsx
const onSave = (e: React.FormEvent<HTMLFormElement>) => { // old
  e.preventDefault(); // old

  const validation = draft.validate();
  if (validation.errors.length > 0) {
    console.log(validation.errors);
    return;
  }

  me.root.orders.push(me.root.draft as BubbleTeaOrder); // old

  me.root.draft = DraftBubbleTeaOrder.create(  // old
    {}, // old
    { owner: me }, // old
  ); // old
}; // old
```
</CodeGroup>

## Draft indicator for better UX

Because we are saving the user's work-in-progress, they can come back to it anytime without losing their work. ðŸ™Œ

To improve the UX even further, in just a few more steps, we can tell the user that they currently have unsaved changes.

Simply add a `hasChanges` checker to your schema.

<CodeGroup>
```ts
// schema.ts
export class DraftBubbleTeaOrder extends CoMap { // old
  name = co.optional.string; // old

  validate() { // old
    const errors: string[] = []; // old

    if (!this.name) { // old
      errors.push("Plese enter a name."); // old
    } // old

    return { errors }; // old
  } // old

  get hasChanges() {
    return Object.keys(this._edits).length
  }
} // old
```
</CodeGroup>

In the UI, you can choose how you want to show the draft indicator.

<CodeGroup>
```tsx
// DraftIndicator.tsx
export function DraftIndicator() {
  const { me } = useAccount({
    root: { draft: {} },
  });

  if (me?.root.draft?.hasChanges) {
    return (
      <p>You have a draft</p>
    );
  }
}
```
</CodeGroup>

A more subtle way is to show a small dot next to the Create button.

<div className="not-prose border p-5 text-center">
  <button type="button" className="relative border rounded-md py-2 px-4 text-center shadow-sm">
    Create order
    <span
      title="You have a draft"
      className="absolute -top-1 -right-1 bg-blue-500 border-2 border-white w-3 h-3 rounded-full dark:border-stone-925"
    >
    </span>
  </button>
</div>

## Handling different types of data

Forms can be more complex than just a single string field, so we've put together an example app that shows you
how to handle single-select, multi-select, date, and boolean inputs.

[See the full example here.](https://github.com/garden-co/jazz/tree/main/examples/form)

<CodeGroup>
```tsx
export class BubbleTeaOrder extends CoMap {
  baseTea = co.literal(...BubbleTeaBaseTeaTypes);
  addOns = co.ref(ListOfBubbleTeaAddOns);
  deliveryDate = co.Date;
  withMilk = co.boolean;
  instructions = co.optional.string;
}
  ```
</CodeGroup>
