import { HeroHeader } from "gcmp-design-system/src/app/components/molecules/HeroHeader";
import { JazzLogo } from "@/components/logos";
import { ComingSoonBadge } from 'gcmp-design-system/src/app/components/atoms/ComingSoonBadge'

<div className="not-prose">
<HeroHeader
    title={<>Learn some <JazzLogo className="h-[1.3em] relative -top-0.5 inline-block -ml-[0.1em] -mr-[0.1em]"/></>}
    slogan="Build an issue tracker with distributed state."
    pt={false}
/>
</div>

Our issues app will be quite simple, but it will have team collaboration. <span className="text-nowrap">**Let's call it... &ldquo;Circular.&rdquo;**</span>

We'll build everything **step-by-step,** in typical, immediately usable stages. We'll explore many important things Jazz does &mdash; so **follow along** or **just pick things out.**

<h2 id="guide-setup">Project Setup</h2>

1. Create a project called "circular" from a generic Vite starter template:

    {/* prettier-ignore */}
    ```bash
    npx degit gardencmp/vite-ts-react-tailwind circular
    cd circular
    npm install
    npm run dev
    ```

    You should now have an empty app running, typically at [localhost:5173](http://localhost:5173).<br/>

    <small>
        (If you make changes to the code, the app will automatically refresh.)
    </small>

2. Install `jazz-tools` and `jazz-react`<br/>

    <small>(in a new terminal window):</small>

    {/* prettier-ignore */}
    ```bash
    cd circular
    npm install jazz-tools jazz-react
    ```

3. Modify `src/main.tsx` to set up a Jazz context:

    {/* prettier-ignore */}
    ```tsx
    import React from "react"; // old
    import ReactDOM from "react-dom/client"; // old
    import App from "./App.tsx"; // old
    import "./index.css"; // old
    import {
        createJazzReactApp,
        useDemoAuth,
        DemoAuthBasicUI,
    } from "jazz-react";
     // old
    const Jazz = createJazzReactApp();
    export const { useAccount, useCoState } = Jazz;

    function JazzAndAuth({ children }: { children: React.ReactNode }) {
        const [auth, authState] = useDemoAuth();

        return (
            <>
                <Jazz.Provider
                    auth={auth}
                    // replace `you@example.com` with your email as a temporary API key
                    peer="wss://mesh.jazz.tools/?key=you@example.com"
                >
                    {children}
                </Jazz.Provider>
                <DemoAuthBasicUI appName="Circular" state={authState} />
            </>
        );
    }

    // old
    ReactDOM.createRoot(document.getElementById("root")!).render( // old
        <React.StrictMode> // old
            <JazzAndAuth>
                <App />
            </JazzAndAuth>
        </React.StrictMode>// old
    ); // old
    ```

    This sets Jazz up, extracts app-specific hooks for later, and wraps our app in the provider.

TODO: explain Auth

<h2 id="intro-to-covalues">Intro to CoValues</h2>

Let's learn about the **central idea** behind Jazz: **Collaborative Values.**

What if we could **treat distributed state like local state?** That's what CoValues do.

We can

-   **create** CoValues, anywhere
-   **load** CoValues by `ID`, from anywhere else
-   **edit** CoValues, from anywhere, by mutating them like local state
-   **subscribe to edits** in CoValues, whether they're local or remote

<h3 id="declaring-covalues">Declaring our own CoValues</h3>

To make our own CoValues, we first need to declare a schema for them. Think of a schema as a combination of TypeScript types and runtime type information.

Let's start by defining a schema for our most central entity in Circular: an **Issue.**

Create a new file `src/schema.ts` and add the following:

```ts
import { CoMap, co } from "jazz-tools";

export class Issue extends CoMap {
    title = co.string;
    description = co.string;
    estimate = co.number;
    status? = co.literal("backlog", "in progress", "done");
}
```

TODO: explain what's happening

<h3 id="reading-covalues">Reading from CoValues</h3>

CoValues are designed to be read like simple local JSON state. Let's see how we can read from an Issue by building a component to render one.

Create a new file `src/components/Issue.tsx` and add the following:

{/* prettier-ignore */}
```tsx
import { Issue } from "../schema";

export function IssueComponent({ issue }: { issue: Issue }) {
    return (
        <div className="grid grid-cols-6 text-sm border-r border-b [&>*]:p-2 [&>*]:border-l [&>*]:border-t">
            <h2>{issue.title}</h2>
            <p className="col-span-3">{issue.description}</p>
            <p>Estimate: {issue.estimate}</p>
            <p>Status: {issue.status}</p>
        </div>
    );
}
```

Simple enough!

<h3 id="creating-covalues">Creating CoValues</h3>

To actually see an Issue, we have to create one. This is where things start to get interesting...

Let's modify `src/App.tsx` to prepare for creating an Issue and then rendering it:

{/* prettier-ignore */}
```tsx
import { useState } from "react";
import { Issue } from "./schema";
import { IssueComponent } from "./components/Issue.tsx";
// old
function App() {// old
    const [issue, setIssue] = useState<Issue>();
    // old
    if (issue) {
        return <IssueComponent issue={issue} />;
    } else {
        return <button>Create Issue</button>;
    }
} // old
// old
export default App; // old
```

Now, finally, let's implement creating an issue:

{/* prettier-ignore */}
```tsx
import { useState } from "react"; // old
import { Issue } from "./schema"; // old
import { IssueComponent } from "./components/Issue.tsx"; // old
import { useAccount } from "./main";
// old
function App() {// old
    const { me } = useAccount();
    const [issue, setIssue] = useState<Issue>(); // old
    // old
    const createIssue = () => {
        const newIssue = Issue.create(
            {
                title: "Buy terrarium",
                description: "Make sure it's big enough for 10 snails.",
                estimate: 5,
                status: "backlog",
            },
            { owner: me },
        );
        setIssue(newIssue);
    };
    // old
    if (issue) {// old
        return <IssueComponent issue={issue} />; // old
    } else { // old
        return <button onClick={createIssue}>Create Issue</button>;
    } // old
} // old
// old
export default App; // old
```

üèÅ Now you should be able to create a new issue by clicking the button and then see it rendered!

<div className="text-xs uppercase text-stone-400 dark:text-stone-600 tracking-wider -mb-3">
    Preview
</div>
<div className="p-3 md:-mx-3 rounded border border-stone-100 dark:border-stone-900 bg-white dark:bg-black not-prose">
    <div className="grid grid-cols-6 text-sm border-r border-b [&>*]:p-2 [&>*]:border-l [&>*]:border-t">
        <h2>Buy terrarium</h2>
        <p className="col-span-3">Make sure it's big enough for 10 snails.</p>
        <p>Estimate: 5</p>
        <p>Status: backlog</p>
    </div>
</div>

We'll already notice one interesting thing here:

-   We have to create every CoValue with an `owner`!
    -   this will determine access rights on the CoValue, which we'll learn about in "Groups & Permissions"
    -   here we set `owner` to the current user `me`, which we get from the Jazz context / `useAccount`

**Behind the scenes, Jazz not only creates the Issue in memory but also automatically syncs an encrypted version to the cloud and persists it locally. The Issue also has a globally unique ID.**

We'll make use of both of these facts in a bit, but for now let's start with local editing and subscribing.

<h3 id="editing-and-subscription">Editing CoValues and subscribing to edits</h3>

Since we're the owner of the CoValue, we should be able to edit it, right?

And since this is a React app, it would be nice to subscribe to edits of the CoValue and reactively re-render the UI, like we can with local state.

This is exactly what the `useCoState` hook is for!

-   Note that `useCoState` doesn't take a CoValue directly, but rather a CoValue's schema, plus its `ID`.
    -   So we'll slightly adapt our `useState` to only keep track of an issue ID...
    -   ...and then use `useCoState` to get the actual issue

Let's modify `src/App.tsx`:

{/* prettier-ignore */}
```tsx
import { useState } from "react"; // old
import { Issue } from "./schema"; // old
import { IssueComponent } from "./components/Issue.tsx"; // old
import { useAccount, useCoState } from "./main";
import { ID } from "jazz-tools"
// old
function App() { // old
    const { me } = useAccount(); // old
    const [issueID, setIssueID] = useState<ID<Issue>>();
    // old
    const issue = useCoState(Issue, issueID);
    // old
    const createIssue = () => {// old
        const newIssue = Issue.create(// old
            { // old
                title: "Buy terrarium", // old
                description: "Make sure it's big enough for 10 snails.", // old
                estimate: 5, // old
                status: "backlog", // old
            }, // old
            { owner: me }, // old
        ); // old
        setIssueID(newIssue.id);
    }; // old
    // old
    if (issue) { // old
        return <IssueComponent issue={issue} />; // old
    } else { // old
        return <button onClick={createIssue}>Create Issue</button>; // old
    } // old
} // old
// old
export default App; // old
```

And now for the exciting part! Let's make `src/components/Issue.tsx` an editing component.

{/* prettier-ignore */}
```tsx
import { Issue } from "../schema"; // old
// old
export function IssueComponent({ issue }: { issue: Issue }) { // old
    return ( // old
        <div className="grid grid-cols-6 text-sm border-r border-b [&>*]:p-2 [&>*]:border-l [&>*]:border-t"> // old
            <input type="text"
                value={issue.title}
                onChange={(event) => { issue.title = event.target.value }}/>
            <textarea className="col-span-3"
                value={issue.description}
                onChange={(event) => { issue.description = event.target.value }}/>
            <label className="flex">
                Estimate:
                <input type="number" className="text-right min-w-0"
                    value={issue.estimate}
                    onChange={(event) => { issue.estimate = Number(event.target.value) }}/>
            </label>
            <select
                value={issue.status}
                onChange={(event) => {
                    issue.status = event.target.value as "backlog" | "in progress" | "done"
                }}
            >
                <option value="backlog">Backlog</option>
                <option value="in progress">In Progress</option>
                <option value="done">Done</option>
            </select>
        </div> // old
    ); // old
} // old
```

<div className="text-xs uppercase text-stone-400 dark:text-stone-600 tracking-wider -mb-3">
    Preview
</div>
<div className="p-3 md:-mx-3 rounded border border-stone-100 dark:border-stone-900 bg-white dark:bg-black not-prose">
    <div className="grid grid-cols-6 text-sm border-r border-b [&>*]:p-2 [&>*]:border-l [&>*]:border-t">
        <input type="text" value={"Buy terrarium"} />
        <input
            type="text"
            className="col-span-3"
            value={"Make sure it's big enough for 10 snails."}
        />
        <label className="flex">
            Estimate:{" "}
            <input type="number" value={5} className="text-right min-w-0" />
        </label>
        <select value={"backlog"}>
            <option value="backlog">Backlog</option>
            <option value="in progress">In Progress</option>
            <option value="done">Done</option>
        </select>
    </div>
</div>

üèÅ Now you should be able to edit the issue after creating it!

You'll immediately notice that we're doing something non-idiomatic for React: we mutate the issue directly, by assigning to its properties.

This works because CoValues

-   intercept these edits
-   update their local view accordingly (React doesn't really care after rendering)
-   notify subscribers of the change (who will receive a fresh, updated view of the CoValue)

<aside className="text-sm border border-stone-300 dark:border-stone-700 rounded px-4 my-4 max-w-3xl [&_pre]:mx-0">
    <h4 className="not-prose text-base py-2 mb-3 -mx-4 px-4 border-b border-stone-300 dark:border-stone-700">üí° A Quick Overview of Subscribing to CoValues</h4>

    There are three main ways to subscribe to a CoValue:

    1.  Directly on an instance:

        ```ts
        const unsub = issue.subscribe([], (updatedIssue) => console.log(updatedIssue));
        ```

    2.  If you only have an ID (this will load the issue if needed):

        ```ts
        const unsub = Issue.subscribe(issueID, me, [], (updatedIssue) => {
            console.log(updatedIssue);
        });
        ```

    3.  If you're in a React component, to re-render reactively:
        `tsx
        const issue = useCoState(Issue, issueID);
        `

            By the way, `useCoState` is basically just an optimized version of

            ```ts
            function useCoState<V extends CoValue>(Schema: CoValueClass<V>, id?: ID<V>): V | undefined {
                const { me } = useAccount();
                const [value, setValue] = useState<V>();

                useEffect(() => Schema.subscribe(id, me, [], setValue), [id]);

                return value;
            }
            ```

</aside>

We have one subscriber on our Issue, with `useCoState` in `src/App.tsx`, which will cause the `App` component and its children **to** re-render whenever the Issue changes.

<h3 id="persistence">Automatic local & cloud persistence</h3>

So far our Issue CoValues just looked like ephemeral local state. We'll now start exploring the first main feature that makes CoValues special: **automatic persistence.**

Actually, all the Issue CoValues we've created so far **have already been automatically persisted** to the cloud and locally - but we loose track of their ID after a reload.

So let's store the ID in window URL state and make sure our useState is in sync with that.

{/* prettier-ignore */}
```tsx
import { useState } from "react"; // old
import { Issue } from "./schema"; // old
import { IssueComponent } from "./components/Issue.tsx"; // old
import { useAccount, useCoState } from "./main"; // old
import { ID } from "jazz-tools" // old
// old
function App() { // old
    const { me } = useAccount(); // old
    const [issueID, setIssueID] = useState<ID<Issue> | undefined>(
        (window.location.search?.replace("?issue=", "") || undefined) as ID<Issue> | undefined,
    );
    // old
    const issue = useCoState(Issue, issueID); // old
    // old
    const createIssue = () => {// old
        const newIssue = Issue.create(// old
            { // old
                title: "Buy terrarium", // old
                description: "Make sure it's big enough for 10 snails.", // old
                estimate: 5, // old
                status: "backlog", // old
            }, // old
            { owner: me }, // old
        ); // old
        setIssueID(newIssue.id); // old
        window.history.pushState({}, "", `?issue=${newIssue.id}`);
    }; // old
    // old
    if (issue) { // old
        return <IssueComponent issue={issue} />; // old
    } else { // old
        return <button onClick={createIssue}>Create Issue</button>; // old
    } // old
} // old
// old
export default App; // old
```

üèÅ Now you should be able to create an issue, edit it, reload the page, and still see the same issue.

<h3 id="remote-sync">Remote sync</h3>

To see that sync is also already working, try the following:

-   copy the URL to a new tab in the same browser window and see the same issue
-   edit the issue and see the changes reflected in the other tab!

This works because we load the issue as the same account that created it and owns it (remember setting `{ owner: me }`?).

We'll learn more about access control in "Groups & Permissions", but for now let's build a super simple way of sharing an Issue by just making it publicly readable & writable.

All we have to do is create a new group to own each new issue and add "everyone" as a "writer":

{/* prettier-ignore */}
```tsx
import { useState } from "react"; // old
import { Issue } from "./schema"; // old
import { IssueComponent } from "./components/Issue.tsx"; // old
import { useAccount, useCoState } from "./main"; // old
import { ID, Group } from "jazz-tools"
// old
function App() { // old
    const { me } = useAccount(); // old
    const [issueID, setIssueID] = useState<ID<Issue> | undefined>(// old
        (window.location.search?.replace("?issue=", "") || undefined) as ID<Issue> | undefined,// old
    ); // old
    // old
    const issue = useCoState(Issue, issueID); // old
    // old
    const createIssue = () => { // old
        const group = Group.create({ owner: me });
        group.addMember("everyone", "writer");
        // old
        const newIssue = Issue.create( // old
            { // old
                title: "Buy terrarium", // old
                description: "Make sure it's big enough for 10 snails.", // old
                estimate: 5, // old
                status: "backlog", // old
            }, // old
            { owner: group },
        ); // old
        setIssueID(newIssue.id); // old
        window.history.pushState({}, "", `?issue=${newIssue.id}`); // old
    }; // old
    // old
    if (issue) { // old
        return <IssueComponent issue={issue} />; // old
    } else { // old
        return <button onClick={createIssue}>Create Issue</button>; // old
    } // old
} // old
// old
export default App; // old
```

üèÅ Now you should be able to open the Issue (with its unique URL) on another device or browser, or send it to a friend and you should be able to **edit it together in realtime!**

This concludes our intro to the essence of CoValues. Hopefully you're starting to have a feeling for how CoValues behave and how they're magically available everywhere.

<h3 id="simple-public-sharing">Simple Public Sharing</h3>
<ComingSoonBadge/>

<h2 id="refs-and-on-demand-subscribe">Refs & Auto-Subscribe</h2>

Now let's have a look at how to compose CoValues into more complex structures and build a whole app around them.

Let's extend our two data model to include "Projects" which have a list of tasks and some properties of their own.

Using plain objects, you would probably type a Project like this:

```ts
type Project = {
    name: string;
    issues: Issue[];
};
```

In order to create this more complex structure in a fully collaborative way, we're going to need _references_ that allow us to nest or link CoValues.

Add the following to `src/schema.ts`:

```ts
import { CoMap, CoList, co } from "jazz-tools";
// old
export class Issue extends CoMap { // old
    title = co.string; // old
    description = co.string; // old
    estimate = co.number; // old
    status? = co.literal("backlog", "in progress", "done"); // old
} // old
// old
export class ListOfIssues extends CoList.Of(co.ref(Issue)) {}

export class Project extends CoMap {
    name = co.string;
    issues = co.ref(ListOfIssues);
}
```

Now let's change things up a bit in terms of components as well.

First, we'll change `App.tsx` to create and render `Project`s instead of `Issue`s. (We'll move the `useCoState` into the `ProjectComponent` we'll create in a second).

{/* prettier-ignore */}
```tsx
import { useState } from "react"; // old
import { Project, ListOfIssues } from "./schema";
import { ProjectComponent } from "./components/Project.tsx";
import { useAccount } from "./main";
import { ID, Group } from "jazz-tools"
// old
function App() { // old
    const { me } = useAccount(); // old
    const [projectID, setProjectID] = useState<ID<Project> | undefined>(
        (window.location.search?.replace("?project=", "") || undefined) as ID<Project> | undefined,
    );
    // old
    const issue = useCoState(Issue, issueID); // *bin*
    // old
    const createProject = () => {
        const group = Group.create({ owner: me });
        group.addMember("everyone", "writer");

        const newProject = Project.create(
            {
                name: "New Project",
                issues: ListOfIssues.create([], { owner: group })
            },
            { owner: group },
        );
        setProjectID(newProject.id);
        window.history.pushState({}, "", `?project=${newProject.id}`);
    };
    // old
    if (projectID) {
        return <ProjectComponent projectID={projectID} />;
    } else {
        return <button onClick={createProject}>Create Project</button>;
    }
} // old
// old
export default App; // old
```

Now we'll actually create the `ProjectComponent` that renders a `Project` and its `Issue`s.

Create a new file `src/components/Project.tsx` and add the following:

{/* prettier-ignore */}
```tsx
import { ID } from "jazz-tools";
import { Project, Issue } from "../schema";
import { IssueComponent } from "./Issue.tsx";
import { useCoState } from "../main";

export function ProjectComponent({ projectID }: { projectID: ID<Project> }) {
    const project = useCoState(Project, projectID);

    const createAndAddIssue = () => {
        project?.issues?.push(Issue.create({
            title: "",
            description: "",
            estimate: 0,
            status: "backlog",
        }, { owner: project._owner }));
    };

    return project ? (
        <div>
            <h1>{project.name}</h1>
            <div className="border-r border-b">
                {project.issues?.map((issue) => (
                    issue && <IssueComponent key={issue.id} issue={issue} />
                ))}
                <button onClick={createAndAddIssue}>Create Issue</button>
            </div>
        </div>
    ) : (
        <div>Loading project...</div>
    );
}
```

üèÅ Now you should be able to create a project, add issues to it, share it, and edit it collaboratively!

Two things to note here:

-   We create a new Issue like before, and then push it into the `issues` list of the Project. By setting the `owner` to the Project's owner, we ensure that the Issue has the same access rights as the project itself.
-   We only need to use `useCoState` on the Project, and the nested `ListOfIssues` and each `Issue` will be **automatically loaded and subscribed to when we access them.**
-   However, because either the `Project`, `ListOfIssues`, or each `Issue` might not be loaded yet, we have to check for them being defined.

The load-and-subscribe-on-access is a convenient way to have your rendering drive data loading (including in nested components!) and lets you quickly chuck UIs together without worrying too much about the shape of all data you'll need.

But you can also take more precise control over loading by defining a minimum-depth to load in `useCoState`:

{/* prettier-ignore */}
```tsx
import { ID } from "jazz-tools";// old
import { Project, Issue } from "../schema"; // old
import { IssueComponent } from "./Issue.tsx"; // old
import { useCoState } from "../main"; // old
// old
export function ProjectComponent({ projectID }: { projectID: ID<Project> }) {// old
    const project = useCoState(Project, projectID, { issues: [{}] });

    const createAndAddIssue = () => {// old
        project?.issues.push(Issue.create({
            title: "",// old
            description: "",// old
            estimate: 0,// old
            status: "backlog",// old
        }, { owner: project._owner }));// old
    };// old
// old
    return project ? (// old
        <div>// old
            <h1>{project.name}</h1>// old
            <div className="border-r border-b">// old
                {project.issues.map((issue) => (
                    <IssueComponent key={issue.id} issue={issue} />
                ))}// old
                <button onClick={createAndAddIssue}>Create Issue</button>// old
            </div>// old
        </div>// old
    ) : (// old
        <div>Loading project...</div>// old
    );// old
}// old
```

The loading-depth spec `{ issues: [{}] }` means "in `Project`, load `issues` and load each item in `issues` shallowly". (Since an `Issue` doesn't have any further references, "shallowly" actually means all its properties will be available).

-   Now, we can get rid of a lot of coniditional accesses because we know that once `project` is loaded, `project.issues` and each `Issue` in it will be loaded as well.
-   This also results in only one rerender and visual update when everything is loaded, which is faster (especially for long lists) and gives you more control over the loading UX.

TODO: explain about not loaded vs not set/defined and `_refs` basics

<div className="text-amber-500 mt-52">
    üöß OH NO - This is as far as we've written the Guide. üöß
</div>
{" -> "}
<a href="https://github.com/gardencmp/jazz/issues/186">Complain on GitHub</a>
